学习笔记
-  摘抄
    1. 分治算法  Divide & Conquer
        分解：将原问题分解成一系列子问题。
        解决：递归地求解个子问题，若子问题足够小，则直接求解。
        合并：将子问题的结果合并成原问题结果。

    2. 分治算法能解决的问题:
        原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别。

    3. 回溯算法  Backtracking
        有规律地枚举所有可能的解，避免遗漏和重复。【剪枝操作】
        回溯算法非常适合用递归来实现。每个递归，我们先随意选一条路走，当发现不符合期望，就回退到递归上一层，另选一种走法继续走。
          
    4. 回溯算法能解决的问题
        深度优先搜索
        八皇后
        0-1 背包问题
        图的着色
        旅行商问题
        数独
        全排列
        正则表达式匹配等等

- 树的存储
    1. 二叉树的两种存储方法： 链式存储法，顺序存储法
    2. 顺序存储法：完全二叉树，用数组存储，下标1代表根节点，如果节点X存储在下标i的位置，则下标i * 2 存储的是左子节点，i * 2 + 1存储的是右子节点

- 树的遍历路径 [树的不同遍历方法提供了处理节点的时机]
    1. 前序遍历
        ```C++
            {
                ....
                display(node);
                inorder(node->left);
                inorder(node->right);
                ....
            }

            注解： 
            1. 沿着遍历【行进】路径先处理左子树结点
            2. 【行进】到最左处子树结点，然后开始处理同父同级右子树结点，回溯父节点处理父节点的右子树
            3. 补充：最左子树结点并不是最深左子树结点       
            4. 遍历函数调用图解: 
                    4
                3       5   ==> 4 -> 3 -> 5

                A. 往左走到最左子树结点O2，边行进边处理(c)， 直到遇见最左N1
                =====================================================================================
                            R(cl1)    <---- R:根结点；c:当前结点已处理；l1:第1次调用左子树遍历函数l；
                        O1(cl2)
                    O2(cl3)     <---- O:非根结点；cl:c在函数l前面，操作c在函数l调用前执行；
                N1   <---- N: 空节点


                B. 处理树结点O2的同父同级右结点N2
                =====================================================================================
                              R(cl1)
                         O1(cl2)
                    O2(cl3r1)      <---- l3r1: 第3次调函数l，第一次调函数r;
                N1           N2


                C. 回溯父节点处理父节点的右子树
                =====================================================================================
                              R(cl1)
                         O1(cl2r2)      <---- 回溯父节点,第2次执行函数r
                    O2(cl3r1)   O3(c)   <---- 同父右结点执行操作c
                N1           N2

                D. 把O3当R结点，重复上面3个动作
                =====================================================================================
                                    R(cl1)
                             O1(cl2r2) 
                    O2(cl3r1)           O3(cl4r3)   <---- 同父右结点调用函数l和函数r
                N1           N2     N3         N4
        ```

    2. 中序遍历：
        ```C++
            {
                ....
                inorder(node->left);
                display(node);
                inorder(node->right);
                ....
            }

            注解：
            1. 沿着遍历【行进】路径到最左子树结点，然后处理当前结点的左结点，再处理右结点
            2. 查询二叉树则是按顺序打印
                4
            3       5   =>  3 -> 4 -> 5
        ```

    3. 后序遍历：        
        ```C++
            {
                ....
                inorder(node->left);
                inorder(node->right);
                display(node);
                ....
            }

            注解：
            1. 沿着遍历【行进】路径到最左子树结点，然后处理左结点，再处理右结点，最后处理根节点
            2. 按顺序打印
                4
            3       5   =>  3 -> 4 -> 5
        ```
        