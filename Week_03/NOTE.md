学习笔记

- 树的遍历路径 [树的不同遍历方法提供了处理节点的时机]
    1. 前序遍历
        ```C++
            {
                ....
                display(node);
                inorder(node->left);
                inorder(node->right);
                ....
            }

            注解： 
            1. 沿着遍历【行进】路径先处理左子树结点
            2. 【行进】到最左处子树结点，然后开始处理同父同级右子树结点，回溯父节点处理父节点的右子树
            3. 补充：最左子树结点并不是最深左子树结点       
            4. 遍历函数调用图解: 
                    4
                3       5   ==> 4 -> 3 -> 5

                A. 往左走到最左子树结点O2，边行进边处理(c)， 直到遇见最左N1
                =====================================================================================
                            R(cl1)    <---- R:根结点；c:当前结点已处理；l1:第1次调用左子树遍历函数l；
                        O1(cl2)
                    O2(cl3)     <---- O:非根结点；cl:c在函数l前面，操作c在函数l调用前执行；
                N1   <---- N: 空节点


                B. 处理树结点O2的同父同级右结点N2
                =====================================================================================
                              R(cl1)
                         O1(cl2)
                    O2(cl3r1)      <---- l3r1: 第3次调函数l，第一次调函数r;
                N1           N2


                C. 回溯父节点处理父节点的右子树
                =====================================================================================
                              R(cl1)
                         O1(cl2r2)      <---- 回溯父节点,第2次执行函数r
                    O2(cl3r1)   O3(c)   <---- 同父右结点执行操作c
                N1           N2

                D. 把O3当R结点，重复上面3个动作
                =====================================================================================
                                    R(cl1)
                             O1(cl2r2) 
                    O2(cl3r1)           O3(cl4r3)   <---- 同父右结点调用函数l和函数r
                N1           N2     N3         N4
        ```

    2. 中序遍历：
        ```C++
            {
                ....
                inorder(node->left);
                display(node);
                inorder(node->right);
                ....
            }

            注解：
            1. 沿着遍历【行进】路径到最左子树结点，然后处理当前结点的左结点，再处理右结点
            2. 查询二叉树则是按顺序打印
                4
            3       5   =>  3 -> 4 -> 5
        ```

    3. 后序遍历：        
        ```C++
            {
                ....
                inorder(node->left);
                inorder(node->right);
                display(node);
                ....
            }

            注解：
            1. 沿着遍历【行进】路径到最左子树结点，然后处理左结点，再处理右结点，最后处理根节点
            2. 按顺序打印
                4
            3       5   =>  3 -> 4 -> 5
        ```